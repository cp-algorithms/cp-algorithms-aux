#ifndef CP_ALGO_MATH_SUBSET_CONVOLUTION_HPP
#define CP_ALGO_MATH_SUBSET_CONVOLUTION_HPP
#include "../util/simd.hpp"
#include "../util/big_alloc.hpp"
#include "../util/bit.hpp"
#include "../util/checkpoint.hpp"
#include <array>
#include <ranges>
#include <algorithm>
#include <bit>
#include <cstring>
CP_ALGO_SIMD_PRAGMA_PUSHnamespace cp_algo::math{const size_t max_logn=20;enum transform_dir{forw,inv};template<auto N,transform_dir direction>inline void or_transform(auto&&a){[[gnu::assume(N<=1<<30)]];if constexpr(N<=32){for(size_t i=1;i<N;i*=2){for(size_t j=0;j<N;j+=2*i){for(size_t k=j;k<j+i;k++){for(size_t z=0;z<max_logn;z++){if constexpr(direction==forw){a[k+i][z]+=a[k][z];}else{a[k+i][z]-=a[k][z];}}}}}}else{constexpr auto half=N/2;or_transform<half,direction>(&a[0]);or_transform<half,direction>(&a[half]);for(size_t i=0;i<half;i++){
#pragma GCC unroll max_logn
for(size_t z=0;z<max_logn;z++){if constexpr(direction==forw){a[i+half][z]+=a[i][z];}else{a[i+half][z]-=a[i][z];}}}}}template<transform_dir direction>inline void or_transform(auto&&a,auto n){with_bit_floor(n,[&]<auto NN>(){assert(NN==n);or_transform<NN,direction>(a);});}template<transform_dir direction=forw>inline void or_transform(auto&&a){or_transform<direction>(a,std::size(a));}auto on_rank_vectors(auto&&cb,auto const&...inputs){static_assert(sizeof...(inputs)>=1,"on_rank_vectors requires at least one input");auto input_tuple=std::forward_as_tuple(inputs...);auto const&first_input=std::get<0>(input_tuple);using base=std::decay_t<decltype(first_input[0])>;big_vector<base>out(std::size(first_input));auto N=std::size(first_input);constexpr size_t K=4;N=std::max(N,K);const size_t n=std::bit_width(N)-1;const size_t T=std::min<size_t>(n-2,4);const size_t bottoms=1<<(n-T);const auto M=std::size(first_input);auto create_buffers=[bottoms]<typename... Args>(const Args&...){return std::make_tuple(big_vector<std::array<typename std::decay_t<Args>::value_type,max_logn>>(bottoms)...);};auto buffers=std::apply(create_buffers,input_tuple);big_vector<uint32_t>counts(N);for(size_t i=1;i<N;i++){counts[i]=(uint32_t)std::popcount(i);}checkpoint("prepare");for(size_t top=0;top<N;top+=bottoms){std::apply([bottoms](auto&... bufs){(...,memset(bufs.data(),0,sizeof(bufs[0])*bottoms));},buffers);std::apply([&](auto const&... inps){std::apply([&](auto&... bufs){auto init_one=[&](auto const&inp,auto&buf){for(size_t mask=top;;mask=(mask-bottoms)&top){size_t limit=std::min(M,mask+bottoms)-mask;uint32_t count=counts[mask/bottoms]-1;for(size_t bottom=(mask==0);bottom<limit;bottom++){size_t i=bottom|mask;buf[bottom][count+counts[bottom]]+=inp[i];}if(!mask)break;}};(init_one(inps,bufs),...);},buffers);},input_tuple);checkpoint("init");std::apply([](auto&... bufs){(...,or_transform(bufs));},buffers);checkpoint("transform");assert(bottoms%K==0);for(size_t i=0;i<bottoms;i+=K){std::apply([&](auto&... bufs){auto extract_one=[&](auto&buf){std::array<u64x4,max_logn>aa;for(size_t j=0;j<max_logn;j++){for(size_t z=0;z<K;z++){aa[j][z]=buf[i+z][j].getr();}}return aa;};auto aa_tuple=std::make_tuple(extract_one(bufs)...);std::apply(cb,aa_tuple);auto&first_buf=std::get<0>(std::forward_as_tuple(bufs...));const auto&first_aa=std::get<0>(aa_tuple);for(size_t j=0;j<max_logn;j++){for(size_t z=0;z<K;z++){first_buf[i+z][j].setr((uint32_t)first_aa[j][z]);}}},buffers);}checkpoint("dot");auto&first_buf=std::get<0>(buffers);or_transform<inv>(first_buf);checkpoint("transform");for(size_t mask=top;mask<N;mask=(mask+bottoms)|top){bool parity=__builtin_parity(uint32_t(mask^top));size_t limit=std::min(M,mask+bottoms)-mask;uint32_t count=counts[mask/bottoms]-1;for(size_t bottom=(mask==0);bottom<limit;bottom++){size_t i=bottom|mask;if(parity){out[i]-=first_buf[bottom][count+counts[bottom]];}else{out[i]+=first_buf[bottom][count+counts[bottom]];}}}checkpoint("gather");}return out;}template<typename base>big_vector<base>subset_convolution(std::span<base>inpa,std::span<base>inpb){big_vector<base>outpa;with_bit_floor(std::size(inpa),[&]<auto N>(){constexpr size_t lgn=std::bit_width(N)-1;[[gnu::assume(lgn<=max_logn)]];outpa=on_rank_vectors([](auto&a,auto const&b){std::decay_t<decltype(a)>res={};const auto mod=base::mod();const auto imod=math::inv2(-mod);const auto modmod8=base::modmod8();const auto r4=u64x4()+uint64_t(-1)%mod+1;auto add=[&](size_t i){if constexpr(lgn)for(size_t j=0;i+j+1<lgn;j++){res[i+j+1]+=(u64x4)_mm256_mul_epu32(__m256i(a[i]),__m256i(b[j]));}};if constexpr(lgn)for(size_t i=0;i<lgn/2;i++){add(i);}if constexpr(lgn>=20){res[lgn-1]=res[lgn-1]>=modmod8?res[lgn-1]-modmod8:res[lgn-1];res[lgn-2]=res[lgn-2]>=modmod8?res[lgn-2]-modmod8:res[lgn-2];}if constexpr(lgn)for(size_t i=lgn/2;i<lgn;i++){add(i);}if constexpr(lgn)if constexpr(lgn)for(size_t k=0;k<lgn;k++){res[k]=montgomery_reduce(res[k],mod,imod);res[k]=montgomery_mul(res[k],r4,mod,imod);a[k]=res[k]>=mod?res[k]-mod:res[k];}},inpa,inpb);outpa[0]=inpa[0]*inpb[0];for(size_t i=1;i<std::size(inpa);i++){outpa[i]+=inpa[i]*inpb[0]+inpa[0]*inpb[i];}checkpoint("fix 0");});return outpa;}template<typename base>big_vector<base>subset_exp(std::span<base>inpa){if(size(inpa)==1){return big_vector<base>{1};}size_t N=std::size(inpa);auto out0=subset_exp(std::span(inpa).first(N/2));auto out1=subset_convolution<base>(out0,std::span(inpa).last(N/2));out0.insert(end(out0),begin(out1),end(out1));cp_algo::checkpoint("extend out");return out0;}template<typename base>big_vector<big_vector<base>>subset_compose(big_vector<std::span<base>>fd,std::span<base>inpa){if(size(inpa)==1){big_vector<big_vector<base>>res(size(fd),{base(0)});big_vector<base>pw(size(fd[0]),1);for(size_t i=1;i<size(fd[0]);i++){pw[i]=pw[i-1]*inpa[0];}for(size_t i=0;i<size(fd);i++){for(size_t j=0;j<size(fd[i]);j++){res[i][0]+=pw[j]*fd[i][j];}}cp_algo::checkpoint("base case");return res;}size_t N=std::size(inpa);big_vector<base>fdk(size(fd[0]));for(size_t i=0;i+1<size(fdk);i++){fdk[i]=fd.back()[i+1]*base(i+1);}fd.push_back(fdk);cp_algo::checkpoint("fdk");auto deeper=subset_compose(fd,std::span(inpa).first(N/2));for(size_t i=0;i+1<size(fd);i++){auto next=subset_convolution<base>(deeper[i+1],std::span(inpa).last(N/2));deeper[i].insert(end(deeper[i]),begin(next),end(next));}deeper.pop_back();cp_algo::checkpoint("combine");return deeper;}template<typename base>big_vector<base>subset_compose(std::span<base>f,std::span<base>inpa){return subset_compose(big_vector{f},inpa)[0];}}
#pragma GCC pop_options
#endif
