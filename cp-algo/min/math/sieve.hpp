#ifndef CP_ALGO_MATH_SIEVE_HPP
#define CP_ALGO_MATH_SIEVE_HPP
#include "../structures/bit_array.hpp"
#include "../structures/bit_array_util.hpp"
#include "../util/bit.hpp"
#include "../util/checkpoint.hpp"
#include <cstdint>
#include <cstddef>
#include <vector>
#include <span>
#include <algorithm>
#include <cassert>
CP_ALGO_BIT_PRAGMA_PUSHnamespace cp_algo::math{using cp_algo::structures::dynamic_bit_array;using cp_algo::structures::bit_array;constexpr auto wheel_primes=std::array{2u,3u,5u,7u};constexpr uint8_t period=std::ranges::fold_left(wheel_primes,1u,std::multiplies{});constexpr uint8_t coprime=std::ranges::fold_left(wheel_primes,1u,[](auto a,auto b){return a*(b-1);});constexpr auto coprime_wheel=[](auto x){return std::ranges::all_of(wheel_primes,[x](auto p){return x%p;});};constexpr auto res_wheel=[](){std::array<uint8_t,coprime>res;int idx=0;for(uint8_t i=1;i<period;i+=2){if(coprime_wheel(i)){res[idx++]=i;}}return res;}();constexpr auto state_wheel=[](){std::array<uint8_t,period>state;uint8_t idx=0;for(uint8_t i=0;i<period;i++){state[i]=idx;idx+=coprime_wheel(i);}return state;}();constexpr auto add_wheel=[](){std::array<uint8_t,period>add;for(uint8_t i=0;i<period;i++){add[i]=1;while(!coprime_wheel(i+add[i])){add[i]++;}}return add;}();constexpr auto gap_wheel=[](){std::array<uint8_t,coprime>gap;for(uint8_t i=0;i<coprime;i++){gap[i]=add_wheel[res_wheel[i]];}return gap;}();constexpr uint32_t to_ord(uint32_t x){return(x/period)*coprime+state_wheel[x%period];}constexpr uint32_t to_val(uint32_t x){return(x/coprime)*period+res_wheel[x%coprime];}constexpr size_t sqrt_threshold=1<<16;constexpr auto sqrt_prime_bits=[](){const int size=sqrt_threshold/2;bit_array<size>prime;prime.set_all();prime.reset(to_ord(1));for(uint32_t i=res_wheel[1];to_ord(i*i)<size;i+=add_wheel[i%period]){if(prime[to_ord(i)]){for(uint32_t k=i;to_ord(i*k)<size;k+=add_wheel[k%period]){prime.reset(to_ord(i*k));}}}return prime;}();constexpr size_t num_primes=[](){size_t cnt=0;for(uint32_t i=res_wheel[1];i<sqrt_threshold;i+=add_wheel[i%period]){cnt+=sqrt_prime_bits[to_ord(i)];}return cnt;}();constexpr auto sqrt_primes=[](){std::array<uint32_t,num_primes>primes;size_t j=0;for(uint32_t i=res_wheel[1];i<sqrt_threshold;i+=add_wheel[i%period]){if(sqrt_prime_bits[to_ord(i)]){primes[j++]=i;}}return primes;}();struct wheel_t{dynamic_bit_array mask;uint32_t product;};constexpr auto make_wheel(big_vector<uint32_t>primes,uint32_t product){assert(product%period==0&&product/period*coprime%dynamic_bit_array::width==0);wheel_t wheel;wheel.product=product;wheel.mask.resize(product/period*coprime);wheel.mask.set_all();for(auto p:primes){for(uint32_t k=1;p*k<product;k+=add_wheel[k%period]){wheel.mask.reset(to_ord(p*k));}}return wheel;}constexpr void sieve_dense(auto&prime,uint32_t l,uint32_t r,wheel_t const&wheel){if(l>=r)return;const uint32_t width=(uint32_t)dynamic_bit_array::width;uint32_t wl=l/width;uint32_t wr=(r+width-1)/width;uint32_t N=(uint32_t)wheel.mask.words;auto loop=[&](uint32_t i,uint32_t block){auto p_ptr=std::assume_aligned<32>(&prime.word(i));auto m_ptr=std::assume_aligned<32>(&wheel.mask.word(0));
#pragma GCC unroll coprime
for(uint32_t j=0;j<block;j++){p_ptr[j]&=m_ptr[j];}};while(wl+N<=wr){loop(wl,N);wl+=N;}loop(wl,wr-wl);}template<class BitArray>constexpr auto sieve_wheel(BitArray&prime,uint32_t l,uint32_t r,size_t i,int state){static const auto ord_step=[](){big_vector<std::array<uint32_t,2*coprime>>ord_steps(num_primes);for(uint32_t i=0;i<size(sqrt_primes);i++){auto p=sqrt_primes[i];auto&ords=ord_steps[i];auto last=to_ord(p);for(uint32_t j=0;j<coprime;j++){auto next=to_ord(p*(res_wheel[j]+gap_wheel[j]));ords[j]=ords[j+coprime]=next-last;last=next;}}return ord_steps;}();auto&ords=ord_step[i];auto advance=[&](){prime.reset(std::exchange(l,l+ords[state++]));};uint32_t p=sqrt_primes[i];while(l+p*coprime<=r){
#pragma GCC unroll coprime
for(size_t j=0;j<coprime;j++){advance();}state-=coprime;}while(l<r){advance();}state=state>=coprime?state-coprime:state;return std::pair{l,state};}constexpr dynamic_bit_array sieve_wheel(uint32_t N){N++;dynamic_bit_array prime(to_ord(N));prime.set_all();static const auto[wheels,medium_primes_begin]=[](){constexpr size_t max_wheel_size=1<<20;uint32_t product=period*dynamic_bit_array::width>>(size(wheel_primes)-2);big_vector<uint32_t>current;big_vector<wheel_t>wheels;for(size_t i=0;i<size(sqrt_primes);i++){uint32_t p=sqrt_primes[i];if(product*p>max_wheel_size){wheels.push_back(make_wheel(current,product));current={p};product=(period*dynamic_bit_array::width>>(size(wheel_primes)-2))*p;if(product>max_wheel_size){checkpoint("make wheels");return std::pair{wheels,i};}}else{current.push_back(p);product*=p;}}assert(false);}();static constexpr uint32_t dense_block=1<<25;for(uint32_t start=0;start<N;start+=dense_block){uint32_t r=std::min(start+dense_block,N);for(auto const&wheel:wheels){auto l=start/wheel.product*wheel.product;sieve_dense(prime,to_ord(l),to_ord(r),wheel);}}checkpoint("dense sieve");static constexpr uint32_t sparse_block=1<<22;auto[pos,state]=[](){big_vector<uint32_t>pos(num_primes);big_vector<uint8_t>state(num_primes);for(auto[i,p]:sqrt_primes|std::views::enumerate){pos[i]=to_ord(p*p);state[i]=state_wheel[p%period];}return std::pair{pos,state};}();for(uint32_t start=0;start<N;start+=sparse_block){uint32_t r=to_ord(std::min(start+sparse_block,N));for(size_t i=medium_primes_begin;i<size(sqrt_primes);i++){if(state[i]>=r)break;std::tie(pos[i],state[i])=sieve_wheel(prime,pos[i],r,i,state[i]);}}checkpoint("sparse sieve");for(size_t i=0;i<std::min(prime.words,sqrt_prime_bits.words);i++){prime.word(i)=sqrt_prime_bits.word(i);}return prime;}}
#pragma GCC pop_options
#endif
