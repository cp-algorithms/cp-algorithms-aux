#ifndef CP_ALGO_MATH_MULTIVAR_HPP
#define CP_ALGO_MATH_MULTIVAR_HPP
#include "../util/big_alloc.hpp"
#include "../number_theory/modint.hpp"
#include "../math/fft.hpp"
CP_ALGO_SIMD_PRAGMA_PUSH
namespace cp_algo::math::fft{template<modint_type base>struct multivar{big_vector<base>data;big_vector<size_t>ranks;big_vector<size_t>dim;size_t N;size_t rank(size_t i){size_t cur=1,res=0,K=size(dim);for(auto ni:dim){cur*=ni;res+=i/cur;}return res%K;}multivar(auto const&dim):dim(begin(dim),end(dim)),N(std::ranges::fold_left(dim,1,std::multiplies{})){data.resize(N);ranks.resize(N);for(auto[i,x]:ranks|std::views::enumerate){x=rank(i);}checkpoint("multivar init");}void read(){for(auto&it:data){std::cin>>it;}checkpoint("multivar read");}void print(){for(auto&it:data){std::cout<<it<<" ";}std::cout<<"\n";checkpoint("multivar write");}multivar truncated(auto const&new_dim)const{return multivar(*this).truncate_inplace(new_dim);}multivar&truncate_inplace(auto const&new_dim){big_vector<size_t>nd(begin(new_dim),end(new_dim));assert(nd.size()==dim.size());size_t K=nd.size();for(size_t i=0;i<K;i++){assert(nd[i]<=dim[i]);}size_t new_N=std::ranges::fold_left(nd,1,std::multiplies{});if(new_N==0){data.clear();dim=std::move(nd);ranks.clear();N=0;return*this;}big_vector<size_t>old_stride(K),new_stride(K);old_stride[0]=1;new_stride[0]=1;for(size_t i=1;i<K;i++){old_stride[i]=old_stride[i-1]*dim[i-1];new_stride[i]=new_stride[i-1]*nd[i-1];}big_vector<size_t>idx(K);size_t old_pos=0,new_pos=0;for(size_t t=0;t<new_N;t++){data[new_pos]=data[old_pos];for(size_t d=0;d<K;d++){idx[d]++;old_pos+=old_stride[d];new_pos+=new_stride[d];if(idx[d]<nd[d]){break;}idx[d]=0;old_pos-=old_stride[d]*nd[d];new_pos-=new_stride[d]*nd[d];}}data.resize(new_N);dim=std::move(nd);N=new_N;ranks.resize(N);for(auto[i,x]:ranks|std::views::enumerate){x=rank(i);}return*this;}multivar&extend(auto const&new_dim){big_vector<size_t>nd(begin(new_dim),end(new_dim));assert(nd.size()==dim.size());size_t K=nd.size();for(size_t i=0;i<K;i++){assert(nd[i]>=dim[i]);}size_t new_N=std::ranges::fold_left(nd,1,std::multiplies{});big_vector<size_t>old_stride(K),new_stride(K);old_stride[0]=1;new_stride[0]=1;for(size_t i=1;i<K;i++){old_stride[i]=old_stride[i-1]*dim[i-1];new_stride[i]=new_stride[i-1]*nd[i-1];}data.resize(new_N);for(size_t old_pos=N;old_pos-->0;){size_t tmp=old_pos;big_vector<size_t>idx(K);for(size_t d=0;d<K;d++){idx[d]=tmp%dim[d];tmp/=dim[d];}size_t new_pos=0;for(size_t d=0;d<K;d++){new_pos+=idx[d]*new_stride[d];}data[new_pos]=data[old_pos];}for(size_t i=0;i<new_N;i++){big_vector<size_t>pos(K);size_t tmp=i;bool in_old=true;for(size_t d=0;d<K;d++){pos[d]=tmp%nd[d];tmp/=nd[d];if(pos[d]>=dim[d]){in_old=false;}}if(!in_old){data[i]=base(0);}}dim=std::move(nd);N=new_N;ranks.resize(N);for(auto[i,x]:ranks|std::views::enumerate){x=rank(i);}return*this;}void mul(multivar<base>const&b){assert(dim==b.dim);size_t K=size(dim);if(K==0){data[0]*=b.data[0];return;}big_vector<dft<base>>A,B;size_t M=std::max(flen,std::bit_ceil(2*N-1)/2);for(size_t i=0;i<K;i++){A.emplace_back(data|std::views::enumerate|std::views::transform([&](auto jx){auto[j,x]=jx;return ranks[j]==i?x:base(0);}),M,false);B.emplace_back(b.data|std::views::enumerate|std::views::transform([&](auto jx){auto[j,x]=jx;return ranks[j]==i?x:base(0);}),M,false);}for(size_t i=0;i<K;i++){dft<base>C(M);cvector X=C.A;for(size_t j=0;j<K;j++){size_t tj=(i-j+K)%K;A[j].template dot<false,false>(B[tj].A,B[tj].B,C.A,C.B,X);}checkpoint("dot");big_vector<base>res((N+flen-1)/flen*flen);C.A.template ifft<false>();C.B.template ifft<false>();X.template ifft<false>();C.recover_mod(X,res,N);for(size_t j=0;j<N;j++){if(i==ranks[j]){data[j]=res[j];}}checkpoint("store");}}};}
#pragma GCC pop_options
#endif
