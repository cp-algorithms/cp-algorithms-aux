#ifndef CP_ALGO_MATH_KARATSUBA_HPP
#define CP_ALGO_MATH_KARATSUBA_HPP
#include "../number_theory/nimber.hpp"
#include "../util/big_alloc.hpp"
#include "../util/bit.hpp"
#include <vector>
#include <bit>
#include <cstdint>
#include <span>
namespace cp_algo::math{constexpr size_t NN=8;template<size_t N>[[gnu::target("avx2,vpclmulqdq")]]void base_conv_f2_64(uint64_t const*a,uint64_t const*b,uint64_t*c){alignas(32)__m128i pr0[2*N]={};alignas(32)__m128i pr1[2*N]={};for(size_t i=0;i+1<N;i+=2){auto va=(__m256i)u64x4{a[i],0,a[i+1],0};for(size_t j=0;j+1<N;j+=2){auto vb=(__m256i)u64x4{b[j],b[j+1],b[j],b[j+1]};(__m256i&)pr0[i+j]^=_mm256_clmulepi64_epi128(va,vb,0);(__m256i&)pr1[i+j]^=_mm256_clmulepi64_epi128(va,vb,16);}}if constexpr(N%2){static_assert(N==1);pr0[0]=nimber::clmul(a[0],b[0]);}c[0]=nimber::reduce_mod(pr0[0]);for(size_t i=1;i<2*N-1;i++){c[i]^=nimber::reduce_mod(pr0[i]^pr1[i-1]);}}template<auto N,auto Add,auto Mul>void base_conv(auto&&_a,auto&&_b,auto&&_c){auto a=std::assume_aligned<32>(&_a[0]);auto b=std::assume_aligned<32>(&_b[0]);auto c=std::assume_aligned<32>(&_c[0]);for(size_t i=0;i<N;i++){for(size_t j=0;j<N;j++){c[i+j]=Add(c[i+j],Mul(a[i],b[j]));}}}template<auto N,auto Add,auto Sub,auto Mul>void _karatsuba(auto&&_a,auto&&_b,auto&&_c){auto a=std::assume_aligned<32>(&_a[0]);auto b=std::assume_aligned<32>(&_b[0]);auto c=std::assume_aligned<32>(&_c[0]);[[gnu::assume(N<=1<<20)]];if constexpr(N<=NN){if constexpr(Mul==nimber::f2_64_product){base_conv_f2_64<N>(a,b,c);}else{base_conv<N,Add,Mul>(_a,_b,_c);}}else{constexpr auto h=N/2;auto a0=a,a1=a+h,b0=b,b1=b+h;_karatsuba<h,Add,Sub,Mul>(a0,b0,c);_karatsuba<h,Add,Sub,Mul>(a1,b1,c+2*h);using base=std::decay_t<decltype(a[0])>;static big_vector<base>buf(4*h);auto f=std::assume_aligned<32>(buf.data());auto sum_a=std::assume_aligned<32>(buf.data()+2*h);auto sum_b=std::assume_aligned<32>(buf.data()+3*h);for(size_t i=0;i<h;i++){sum_a[i]=Add(a0[i],a1[i]);sum_b[i]=Add(b0[i],b1[i]);}memset(f,0,sizeof(base)*2*h);_karatsuba<h,Add,Sub,Mul>(sum_a,sum_b,f);auto c0=std::assume_aligned<32>(c);auto c1=c0+h,c2=c0+2*h;for(size_t i=0;i<h;i++){auto&A=c0[i],&B=c1[i],&C=c2[i],&D=c2[i+h];auto BC=Sub(B,C);B=Sub(Add(BC,f[i]),A);C=Sub(f[i+h],Add(D,BC));}}}template<typename Cont,auto Add,auto Sub,auto Mul>Cont karatsuba(auto&a,auto&b){auto n=std::size(a);auto m=std::size(b);auto N=std::bit_ceil(std::max(n,m));a.resize(N);b.resize(N);Cont c(2*N-1);with_bit_ceil(N,[&]<auto NN>(){_karatsuba<NN,Add,Sub,Mul>(a,b,c);});c.resize(n+m-1);return c;}template<typename Cont=big_vector<uint64_t>>Cont convolution_F2_64(auto&a,auto&b){return karatsuba<Cont,std::bit_xor<>{},std::bit_xor<>{},nimber::f2_64_product>(a,b);}}
#endif
