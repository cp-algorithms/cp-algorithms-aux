#ifndef CP_ALGO_MATH_SUBSET_CONVOLUTION_HPP
#define CP_ALGO_MATH_SUBSET_CONVOLUTION_HPP
#include "../util/simd.hpp"
#include "../util/big_alloc.hpp"
#include "../util/bit.hpp"
#include "../util/checkpoint.hpp"
#include <array>
#include <ranges>
#include <algorithm>
#include <bit>
#include <cstring>
CP_ALGO_SIMD_PRAGMA_PUSH
namespace cp_algo::math{const size_t max_logn=20;enum transform_dir{forw,inv};template<auto N,transform_dir direction>inline void xor_transform(auto&&a){[[gnu::assume(N<=1<<30)]];if constexpr(N<=32){for(size_t i=1;i<N;i*=2){for(size_t j=0;j<N;j+=2*i){for(size_t k=j;k<j+i;k++){for(size_t z=0;z<max_logn;z++){auto x=a[k][z]+a[k+i][z];auto y=a[k][z]-a[k+i][z];a[k][z]=x;a[k+i][z]=y;}}}}}else{auto add=[&](auto&a,auto&b)__attribute__((always_inline)){auto x=a+b,y=a-b;a=x,b=y;};constexpr auto quar=N/4;for(size_t i=0;i<(size_t)quar;i++){auto x0=a[i+(size_t)quar*0];auto x1=a[i+(size_t)quar*1];auto x2=a[i+(size_t)quar*2];auto x3=a[i+(size_t)quar*3];
#pragma GCC unroll max_logn
for(size_t z=0;z<max_logn;z++){add(x0[z],x2[z]);add(x1[z],x3[z]);}
#pragma GCC unroll max_logn
for(size_t z=0;z<max_logn;z++){add(x0[z],x1[z]);add(x2[z],x3[z]);}a[i+(size_t)quar*0]=x0;a[i+(size_t)quar*1]=x1;a[i+(size_t)quar*2]=x2;a[i+(size_t)quar*3]=x3;}xor_transform<quar,direction>(&a[quar*0]);xor_transform<quar,direction>(&a[quar*1]);xor_transform<quar,direction>(&a[quar*2]);xor_transform<quar,direction>(&a[quar*3]);}}template<transform_dir direction>inline void xor_transform(auto&&a,auto n){with_bit_floor(n,[&]<auto NN>(){assert(NN==n);xor_transform<NN,direction>(a);});}template<transform_dir direction=forw>inline void xor_transform(auto&&a){xor_transform<direction>(a,std::size(a));}auto on_rank_vectors(auto&&cb,auto const&...inputs){static_assert(sizeof...(inputs)>=1,"on_rank_vectors requires at least one input");auto input_tuple=std::forward_as_tuple(inputs...);auto const&first_input=std::get<0>(input_tuple);using base=std::decay_t<decltype(first_input[0])>;big_vector<base>out(std::size(first_input));auto N=std::size(first_input);constexpr size_t K=4;N=std::max(N,2*K);const size_t n=std::bit_width(N)-1;const size_t T=std::min<size_t>(n-3,2);const size_t bottoms=1<<(n-T-1);const auto M=std::size(first_input);auto create_buffers=[bottoms]<typename... Args>(const Args&...){return std::make_tuple(big_vector<std::array<typename std::decay_t<Args>::value_type,max_logn>>(bottoms)...);};auto buffers=std::apply(create_buffers,input_tuple);checkpoint("alloc buffers");big_vector<uint32_t>counts(2*bottoms);for(size_t i=1;i<2*bottoms;i++){counts[i]=(uint32_t)std::popcount(i);}checkpoint("prepare");for(size_t top=0;top<N/2;top+=bottoms){std::apply([bottoms](auto&... bufs){(...,memset(bufs.data(),0,sizeof(bufs[0])*bottoms));},buffers);checkpoint("memset");std::apply([&](auto const&... inps){std::apply([&](auto&... bufs){auto init_one=[&](auto const&inp,auto&buf){for(size_t i=0;i<M;i+=2*bottoms){bool parity=__builtin_parity(uint32_t((i>>1)&top));size_t limit=std::min(M,i+2*bottoms)-i;uint32_t count=(uint32_t)std::popcount(i)-1;for(size_t bottom=(i==0);bottom<limit;bottom++){if(parity){buf[bottom>>1][count+counts[bottom]]-=inp[i+bottom];}else{buf[bottom>>1][count+counts[bottom]]+=inp[i+bottom];}}}};(init_one(inps,bufs),...);},buffers);},input_tuple);checkpoint("init");std::apply([](auto&... bufs){(...,xor_transform(bufs));},buffers);checkpoint("transform");assert(bottoms%K==0);for(size_t i=0;i<bottoms;i+=K){std::apply([&](auto&... bufs){auto extract_one=[&](auto&buf){std::array<u64x4,max_logn>aa;for(size_t j=0;j<max_logn;j++){for(size_t z=0;z<K;z++){aa[j][z]=buf[i+z][j].getr();}}return aa;};auto aa_tuple=std::make_tuple(extract_one(bufs)...);std::apply(cb,aa_tuple);auto&first_buf=std::get<0>(std::forward_as_tuple(bufs...));const auto&first_aa=std::get<0>(aa_tuple);for(size_t j=0;j<max_logn;j++){for(size_t z=0;z<K;z++){first_buf[i+z][j].setr((uint32_t)first_aa[j][z]);}}},buffers);}checkpoint("dot");auto&first_buf=std::get<0>(buffers);xor_transform<inv>(first_buf);checkpoint("transform");for(size_t i=0;i<M;i+=2*bottoms){bool parity=__builtin_parity(uint32_t((i>>1)&top));size_t limit=std::min(M,i+2*bottoms)-i;uint32_t count=(uint32_t)std::popcount(i)-1;for(size_t bottom=(i==0);bottom<limit;bottom++){if(parity){out[i+bottom]-=first_buf[bottom>>1][count+counts[bottom]];}else{out[i+bottom]+=first_buf[bottom>>1][count+counts[bottom]];}}}checkpoint("gather");}const base ni=base(N/2).inv();for(auto&x:out){x*=ni;}return out;}template<typename base>big_vector<base>subset_convolution(std::span<base>f,std::span<base>g){big_vector<base>outpa;with_bit_floor(std::size(f),[&]<auto N>(){constexpr size_t lgn=std::bit_width(N)-1;[[gnu::assume(lgn<=max_logn)]];outpa=on_rank_vectors([](auto&a,auto const&b){std::decay_t<decltype(a)>res={};const auto mod=base::mod();const auto imod=math::inv2(-mod);const auto r4=u64x4()+uint64_t(-1)%mod+1;auto add=[&](size_t i){if constexpr(lgn)for(size_t j=0;i+j+1<lgn;j++){res[i+j+1]+=(u64x4)_mm256_mul_epu32(__m256i(a[i]),__m256i(b[j]));}};if constexpr(lgn)for(size_t i=0;i<lgn;i++){add(i);}if constexpr(lgn)if constexpr(lgn)for(size_t k=0;k<lgn;k++){res[k]=montgomery_reduce(res[k],mod,imod);res[k]=montgomery_mul(res[k],r4,mod,imod);a[k]=res[k]>=mod?res[k]-mod:res[k];}},f,g);outpa[0]=f[0]*g[0];for(size_t i=1;i<std::size(f);i++){outpa[i]+=f[i]*g[0]+f[0]*g[i];}checkpoint("fix 0");});return outpa;}template<typename base>big_vector<base>subset_exp(std::span<base>g){if(size(g)==1){return big_vector<base>{1};}size_t N=std::size(g);auto out0=subset_exp(std::span(g).first(N/2));auto out1=subset_convolution<base>(out0,std::span(g).last(N/2));out0.insert(end(out0),begin(out1),end(out1));cp_algo::checkpoint("extend out");return out0;}template<typename base>big_vector<big_vector<base>>subset_compose(std::span<base>f,std::span<base>g,size_t n){if(size(g)==1){size_t M=size(f);big_vector res(n,big_vector<base>{0});big_vector<base>pw(std::max(n,M));pw[0]=1;for(size_t j=1;j<M;j++){pw[j]=pw[j-1]*g[0];}for(size_t i=0;i<n;i++){for(size_t j=0;j<M;j++){res[i][0]+=pw[j]*f[j];}for(size_t j=M;j>i;j--){pw[j]=pw[j-1]*base(j);}pw[i]=0;}cp_algo::checkpoint("base case");return res;}size_t N=std::size(g);auto deeper=subset_compose(f,std::span(g).first(N/2),n+1);for(size_t i=0;i+1<size(deeper);i++){auto next=subset_convolution<base>(deeper[i+1],std::span(g).last(N/2));deeper[i].insert(end(deeper[i]),begin(next),end(next));}deeper.pop_back();cp_algo::checkpoint("combine");return deeper;}template<typename base>big_vector<base>subset_compose(std::span<base>f,std::span<base>g){return subset_compose(f,g,1)[0];}template<typename base>big_vector<base>subset_conv_transpose(std::span<base>h,std::span<base>g){std::ranges::reverse(h);auto res=subset_convolution<base>(h,g);std::ranges::reverse(h);std::ranges::reverse(res);return res;}template<typename base>big_vector<base>subset_power_projection(big_vector<big_vector<base>>&&fg,std::span<base>g,size_t M){if(size(g)==1){size_t n=size(fg);big_vector<base>res(M);big_vector<base>pw(std::max(n,M));pw[0]=1;for(size_t j=1;j<M;j++){pw[j]=pw[j-1]*g[0];}for(size_t i=0;i<size(fg);i++){for(size_t j=0;j<M;j++){res[j]+=pw[j]*fg[i][0];}for(size_t j=M;j>i;j--){pw[j]=pw[j-1]*base(j);}pw[i]=0;}cp_algo::checkpoint("base case");return res;}size_t N=std::size(g);fg.emplace_back(N/2);for(auto&&[i,h]:fg|std::views::enumerate|std::views::reverse|std::views::drop(1)){auto prev=subset_conv_transpose<base>(std::span(h).last(N/2),std::span(g).last(N/2));for(size_t j=0;j<N/2;j++){fg[i+1][j]+=prev[j];}fg[i+1].resize(N/2);}fg[0].resize(N/2);cp_algo::checkpoint("decombine");return subset_power_projection(std::move(fg),std::span(g).first(N/2),M);}template<typename base>big_vector<base>subset_power_projection(std::span<base>g,std::span<base>w,size_t M){return subset_power_projection({{begin(w),end(w)}},g,M);}}
#pragma GCC pop_options
#endif
