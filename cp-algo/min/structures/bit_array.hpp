#ifndef CP_ALGO_STRUCTURES_BIT_ARRAY_HPP
#define CP_ALGO_STRUCTURES_BIT_ARRAY_HPP
#include "../util/bit.hpp"
#include "../util/big_alloc.hpp"
#include <cassert>
CP_ALGO_SIMD_PRAGMA_PUSHnamespace cp_algo::structures{template<typename C>concept Resizable=requires(C&c,std::size_t n){c.resize(n);};template<class Cont>struct _bit_array{using word_t=typename Cont::value_type;static constexpr size_t width=bit_width<word_t>;size_t words,n;alignas(32)Cont data;constexpr void resize(size_t N){n=N;words=(n+width-1)/width;if constexpr(Resizable<Cont>){data.resize(words);}else{assert(std::size(data)>=words);}}constexpr _bit_array():data(){if constexpr(!Resizable<Cont>){resize(std::size(data)*width);}else{resize(0);}}constexpr _bit_array(size_t N):data(){resize(N);}constexpr word_t&word(size_t x){return data[x];}constexpr word_t word(size_t x)const{return data[x];}constexpr void set_all(word_t val=-1){for(size_t i=0;i<words;i++){data[i]=val;}}constexpr void reset(){set_all(0);}constexpr void set(size_t x){word(x/width)|=1ULL<<(x%width);}constexpr void reset(size_t x){word(x/width)&=~(1ULL<<(x%width));}constexpr void flip(size_t x){word(x/width)^=1ULL<<(x%width);}constexpr bool test(size_t x)const{return(word(x/width)>>(x%width))&1;}constexpr bool operator[](size_t x)const{return test(x);}constexpr size_t size()const{return n;}auto operator<=>(_bit_array const&t)const=default;constexpr _bit_array&xor_hint(_bit_array const&t,size_t hint){for(size_t i=hint/width;i<words;i++){data[i]^=t.data[i];}return*this;}constexpr _bit_array&operator^=(_bit_array const&t){return xor_hint(t,0);}constexpr _bit_array operator^(_bit_array const&t)const{return _bit_array(*this)^=t;}};template<size_t N>using bit_array=_bit_array<std::array<uint64_t,(N+63)/64>>;using dynamic_bit_array=_bit_array<big_vector<uint64_t>>;}
#pragma GCC pop_options
#endif
